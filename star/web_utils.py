import logging
import traceback
import os
import time
import functools
from collections.abc import Callable, Awaitable
from collections.abc import AsyncGenerator
from pathlib import Path
from quart import request, render_template_string

from star.error import ExpectedJson, BadArguments, JsonPayloadError, ServerError, CacheMiss
from star.state import State
from star.events import ServerEvent
from star.response import JsonResponse, WebResponse, WebEvent, ServerSentEventResponse
from star.web_event import BaseEvent


logger = logging.getLogger('star')


def define_async_api(func: Callable[..., Awaitable[WebResponse]]):
    """
    ### Decorator for async API functions with error handling

    *Docstring generated by AI.*

    Wraps async API functions to automatically catch and handle ServerError exceptions,
    converting them into appropriate HTTP responses. Logs warnings for any API errors
    and ensures consistent error response formatting across all async API endpoints.

    **Async:** No (decorator function itself is synchronous)

    **Args:**
    - `func` (`Callable[..., Awaitable[WebResponse]]`): The async API function to wrap with error handling.

    **Returns:**
    - `Callable[..., Awaitable[WebResponse]]`: A wrapped function that handles ServerError exceptions automatically.

    **Example:**
    ```python
    @define_async_api
    async def my_api_function() -> WebResponse:
        return Ok()
    # Callable[..., Awaitable[WebResponse]]
    ```
    """

    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ServerError as e:
            logger.warning(f'API error: {e}')
            logger.debug(f'Exception traceback:\n{traceback.format_exc()}')
            return e.as_response_code()

    return wrapper


def define_api(func: Callable[..., WebResponse]):
    """
    ### Decorator for synchronous API functions with error handling

    *Docstring generated by AI.*

    Wraps synchronous API functions to automatically catch and handle ServerError exceptions,
    converting them into appropriate HTTP responses. Logs warnings for any API errors
    and ensures consistent error response formatting across all synchronous API endpoints.

    **Async:** No

    **Args:**
    - `func` (`Callable[..., WebResponse]`): The synchronous API function to wrap with error handling.

    **Returns:**
    - `Callable[..., WebResponse]`: A wrapped function that handles ServerError exceptions automatically.

    **Example:**
    ```python
    @define_api
    def my_sync_api_function() -> WebResponse:
        return Ok()
    # Callable[..., WebResponse]
    ```
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ServerError as e:
            logger.warning(f'API error: {e}')
            logger.debug(f'Exception traceback:\n{traceback.format_exc()}')
            return e.as_response_code()

    return wrapper


def url_endpoint(func: Callable[..., Awaitable[WebResponse]]):
    """
    ### Decorator for URL endpoint functions with error handling

    *Docstring generated by AI.*

    Wraps URL endpoint functions to automatically catch and handle ServerError exceptions,
    converting them into appropriate HTTP responses. Provides error handling specifically
    for URL-based endpoints with appropriate logging for debugging URL API issues.

    **Async:** No (decorator function itself is synchronous)

    **Args:**
    - `func` (`Callable[..., Awaitable[WebResponse]]`): The URL endpoint function to wrap with error handling.

    **Returns:**
    - `Callable[..., Awaitable[WebResponse]]`: A wrapped function that handles ServerError exceptions for URL endpoints.

    **Example:**
    ```python
    @url_endpoint
    async def my_url_endpoint() -> WebResponse:
        return Ok()
    # Callable[..., Awaitable[WebResponse]]
    ```
    """

    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ServerError as e:
            logger.warning(f'Error in URL API: {e}')
            return e.as_response_code()

    return wrapper


def json_endpoint(func: Callable[..., Awaitable[JsonResponse]]):
    """
    ### Decorator for JSON endpoint functions with request parsing and error handling

    *Docstring generated by AI.*

    Wraps JSON endpoint functions to automatically parse JSON request data and merge it with
    function arguments. Handles JSON parsing errors, duplicate key conflicts, type errors,
    and ServerError exceptions. Ensures all JSON endpoints receive properly parsed data
    and return consistent error responses for malformed requests.

    **Async:** No (decorator function itself is synchronous)

    **Args:**
    - `func` (`Callable[..., Awaitable[JsonResponse]]`): The JSON endpoint function to wrap with request parsing and error
    handling.

    **Raises:**
    - `JsonPayloadError`: When duplicate keys are found between request JSON and function arguments.
    - `BadArguments`: When function arguments don't match the expected signature.
    - `ExpectedJson`: When no JSON payload is provided in the request.

    **Returns:**
    - `Callable[..., Awaitable[JsonResponse]]`: A wrapped function that parses JSON requests and handles errors.

    **Example:**
    ```python
    @json_endpoint
    async def my_json_endpoint(name: str) -> JsonResponse:
        return JsonResponse({'message': f'Hello {name}'})
    # Callable[..., Awaitable[JsonResponse]]
    ```
    """

    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        converted_json = await request.get_json()
        if converted_json is not None:
            for key in converted_json.keys():
                if key in kwargs:
                    logger.warning(f'Duplicate key found while parsing arguments: {key}')
                    return JsonPayloadError().as_response_code()

            kwargs.update(converted_json)
            try:
                return await func(*args, **kwargs)
            except TypeError as e:
                logger.warning(e)
                logger.warning(f'Request passed args: {args}')
                logger.warning(f'Request payload: {kwargs}')
                return BadArguments().as_response_code()
            except ServerError as e:
                logger.warning(e)
                return e.as_response_code()
        else:
            return ExpectedJson().as_response_code()

    return wrapper


def html_endpoint(*, template_path: Path | str, title: str | None = None, expire_event: ServerEvent | None = None):
    """
    ### Decorator for HTML endpoint functions with template caching and rendering

    *Docstring generated by AI.*

    Wraps HTML endpoint functions to provide automatic template loading, caching, and rendering.
    Aggressively caches both page templates and rendered content to avoid unnecessary disk reads.
    Monitors file modification times to automatically invalidate cache when templates change.
    Renders the final page by injecting function output into the base page template.

    **Async:** No (decorator function itself is synchronous)

    **Args:**
    - `template_path` (`Path | str`): The path to the HTML template file relative to the templates directory.
    - `title` (`str | None`): The page title to use in the rendered template. Defaults to 'Bourbon Warfare'.
    - `expire_event` (`ServerEvent | None`): Optional event that will invalidate the cache when triggered.

    **Returns:**
    - `Callable`: A decorator function that wraps HTML endpoint functions with template rendering capabilities.

    **Example:**
    ```python
    @html_endpoint(template_path='dashboard.html', title='Dashboard')
    async def dashboard_page(html: str) -> str:
        return render_template_string(html, data={'status': 'active'})
    # Callable[..., Awaitable[str]]
    ```
    """
    if isinstance(template_path, str):
        template_path = Path(template_path)

    original_template_path = str(template_path)
    page_hash = original_template_path + '--FULL'
    templates_path = Path('./static') / 'templates'

    page_path = templates_path / 'page.html'
    template_path = templates_path / template_path

    def decorator(func: Callable[..., Awaitable[str]]):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # We aggressivley cache the page and template to avoid unnecessary disk reads.
            # If the page or template has changed, we will re-read them and re-render the page.
            try:
                full_page, last_update = State.cache[page_hash]
            except CacheMiss:
                full_page = None
                last_update = 0

            page_update_time = os.path.getmtime(page_path)
            template_update_time = os.path.getmtime(template_path)
            if full_page is None or last_update < page_update_time or last_update < template_update_time:
                try:
                    page, last_update = State.cache['base_page']
                except CacheMiss:
                    page = None
                    last_update = 0

                if page is None or last_update < page_update_time:
                    with open(page_path, encoding='utf-8') as file:
                        page = file.read()
                    State.cache.insert('base_page', (page, page_update_time), expire_event=expire_event)

                try:
                    html, last_update = State.cache[original_template_path]
                except CacheMiss:
                    html = None
                    last_update = 0

                if html is None or last_update < template_update_time:
                    with open(template_path, encoding='utf-8') as file:
                        html = file.read()
                    State.cache.insert(original_template_path, (html, template_update_time), expire_event=expire_event)

                inner_html = await func(html=html, *args, **kwargs)
                full_page = await render_template_string(
                    page,
                    inner_html=inner_html,
                    title=title if title is not None else 'Bourbon Warfare',
                )

                State.cache.insert(page_hash, (full_page, time.time()), expire_event=expire_event)
            return full_page

        return wrapper

    return decorator


def sse_endpoint(func: Callable[..., AsyncGenerator[WebEvent | BaseEvent]]):
    """
    ### Decorator for Server-Sent Events endpoint functions

    *Docstring generated by AI.*

    Wraps SSE endpoint functions to automatically convert async generators into proper
    ServerSentEventResponse objects. Handles conversion of BaseEvent objects to WebEvent
    format for proper SSE transmission. Ensures all SSE endpoints return compatible
    response objects for real-time event streaming.

    **Async:** No (decorator function itself is synchronous)

    **Args:**
    - `func` (`Callable[..., AsyncGenerator[WebEvent | BaseEvent]]`): The SSE endpoint function that yields events.

    **Returns:**
    - `Callable[..., Awaitable[ServerSentEventResponse]]`: A wrapped function that returns a proper SSE response.

    **Example:**
    ```python
    @sse_endpoint
    async def event_stream():
        yield WebEvent('message', {'data': 'Hello'})
    # Callable[..., Awaitable[ServerSentEventResponse]]
    ```
    """

    @functools.wraps(func)
    async def wrapper(*args, **kwargs) -> ServerSentEventResponse:
        generator = func(*args, **kwargs)

        if isinstance(generator, AsyncGenerator[BaseEvent]):

            async def wrapped_generator() -> AsyncGenerator[WebEvent]:
                async for event in func(*args, **kwargs):
                    yield event.as_web_event()

            generator = wrapped_generator()

        return await ServerSentEventResponse.from_async_generator(generator)

    return wrapper
